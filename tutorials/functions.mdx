---
title: Functions
next: intro_to_lists
---

If you've been doing these in order, you had no idea until
now, that functions have been hiding in plain sight!
any block except for the "main" block can be extended to 
take arguments. 

<WereSoCool language={
`{ f: 261.6, l: 1/3, g: 1, p: 0 }\n
melody(a) = {
  a | Repeat 3
}\n
main = {
  melody(
    Seq [
      Fm 5/4, Fm 9/8, Fm 1
    ]
  )
}`
}/>

---

Functions are very powerful. Some of the simplier Bach pieces can be described pretty clearly as a small set of functions run 
a series of different inputs. Here is a more complicated example.


<WereSoCool language={
`{ f: 220, l: 7/8, g: 1/5, p: 0 }\n
overtones = {
  O[
    (7, 0, 1/3, 1),
    (5, 0, 1/3, -1),
    (3, 0, 1, 1),
    (2, 0, 1, -1),
    (1/1, 2, 1, 1),
    (1/1, 0, 1, -1),
    (1/2, 0, 1, 0),
    (1/2, 1, 1, 0),
  ]
}\n
bass_overtones = {
  O[
    (4, 0, 1, 0),
    (4, 0, 1, 0),
    (1/1, 2, 1, 1),
    (1/1, 0, 1, -1),
    (1/2, 2, 1/2, 1),
    (1/2, 0, 1/2, -1),
  ]
}\n
-- This is a function that takes 4 arguments and
-- then plays them in a new order. 
cool_function(a, b, c, d) = {
  Overlay [
    overtones | 
    Seq [
      c, b, a, b, c, d, c | Lm 2
    ],
    -- and also makes a second cool melody
    bass_overtones
    | Seq [
      Fm 0,
      a | Fm 1/2,
      a | Fm 3/4, 
      c | Fm 3/4, 
    ] | Lm 2
  ]
}\n
main = {
  Seq [
    -- And then we can use that function with different
    -- arguments to generate different melodies. 
    cool_function(Fm 1, Fm 9/8, Fm 5/4, Fm 3/2) | Repeat 2, 
    cool_function(Fm 1, Fm 5/4, Fm 3/2, Fm 15/8) | Repeat 2,
    cool_function(Fm 7/6, Fm 9/8, Fm 1, Fm 7/8) | Repeat 2,
    cool_function(Fm 3/2, Fm 3/4, Fm 5/4, Fm 1) | Repeat 2
  ]
  -- Piped into a Seq, we can quickly put together 
  -- a reasonable structure for a song.
  | Seq [Fm 1, Fm 4/3, Fm 7/6, Fm 1]
  | Lm 1/7 
}`
}/>


